#import rpy2.robjects as robjects
import datetime
import numpy
from models.mathUtil import invertPoisson
# import numpy
import datetime
import models.mathUtil as mathUtil
import math
import random

#TODO: the args, check them
def simpleHibrid(model,fileMag,fileSaveCat):
    """
    function to merge the etasGaModel generated by GA with the mag catalog from the R package SAPP 
    """

    model.magnitudeValues = numpy.zeros(shape=(len(model.bins),model.definitions[2]['cells']), dtype='f')
    finished = sum(model.bins)
    f = open(fileMag, 'r')


    quakes = []
    times = []

    for line in f:
        if line[1] == '"':
            continue

        tokens = line.split(',')

        mag = float(tokens[4])
        time = float(tokens[5])
        quakes.append(mag)
        times.append(time)

        i, quakesCount, number = 0, 0, 1
    while quakes != [] and number<finished:
        if i >= len(model.bins):
            break
        j=0 
        while j < len(quakes):
            if  model.bins[i] > quakesCount:
                index = findIndex(model, quakes[j])
                if model.magnitudeValues[i][index] == 0:
                    number += 1
                    model.magnitudeValues[i][index] = quakes.pop(j)
                    times.pop(j)
                    j=0
                    quakesCount+=1
                else:
                    quakes[j]+=0.1
            else:
                i+=1
                quakesCount = 0  
                break
            j+=1
    f.close()

    return model


def findIndex(model, mag):
    """
    This function finds the position of the bin given the mag and position of the list model
    """

    index = 0
    step_mag = model.definitions[2]['step']
    min_mag = model.definitions[2]['min']
    max_mag = model.definitions[2]['min'] + (model.definitions[2]['cells'] * model.definitions[2]['step'])
    cells_mag = model.definitions[2]['cells']

    for n in range(cells_mag):    
        cell = (step_mag * n) + min_mag
        if mag >= cell and mag < (cell+step_mag): 
            if (cell + step_mag) >= max_mag: #to avoid the last index to be out of limits
                index -= 1
            break
        index += 1
    return index

#TODO: it is incrising the number os quakes in line 344
def ideaRIinMmodels(model, nQuakes,steps=5):
    """
    This function distributes the aftershocks of a mainshock based on RI models ideas.
    The aftershocks are located up, down, left and right to the mainshock bin.
    """

    maxIndex = model.definitions[0]['bins']*model.definitions[1]['bins']*model.definitions[2]['bins']-1
    minIndex = 0
    row = model.definitions[0]['bins']

    dataBins, dataIndex = [],[]

    for bins,index in zip(model.bins, range(len(model.bins))):
        if bins > 1:
            dataBins.append(bins)
            dataIndex.append(index)

    for i,j in zip(range(len(dataBins)), range(len(dataIndex))):

        value = dataBins[i]
        index = dataIndex[j]

        for newTarget in range(steps):
            newTarget+=1
            value -= 1

            if nQuakes > value:
                nQuakes -= value
            else:
                value = nQuakes
            

            if value > 0:
                if index-newTarget >= minIndex:
                    model.bins[index-newTarget] += round(value/4)

                if index+newTarget <= maxIndex:
                    model.bins[index+newTarget] += round(value/4)

                if index + newTarget*row <= maxIndex:
                    model.bins[index + newTarget*row] += round(value/4)

                if index - newTarget*row >= minIndex:
                    model.bins[index - newTarget*row] += round(value/4)           

            else:
                break


def pdfOmoriUtsu(t2=30, c=0.003, p=1.3):
    """
    This is the omori utsu formula [g(t-ti)] in the PDF form
    It Analyze earthquake clustering features by using stochastic reconstruction/zhuang
    Is used to add geophysics information to the models
    """
    pdf_triggered = ((p-1)/c)*math.pow((1+t2/c),-p)
    return pdf_triggered


def quakesTriggered(magMain, magThreshold=3):
    """
    It scales realationship between the n of aftershocks and the size of the mainshock
    A = area in km2 connecting afteshock with the mag of the mainshock
    Utsu and Seki (1955) formula/yamanaka
    It analyzes earthquake clustering features by using stochastic reconstruction/zhuang
    """
    alpha = math.pow(magMain,-1)
    A = math.pow(math.e,1.02*magMain -4)
    
    k = A * math.exp(alpha*(magMain-magThreshold))
    return k

def sumTriggeredByDaysWithRI(model, year, fileEtasim, t2=30):
    """
    This function applies the pdfOmoriUtsu and quakesTriggered combined with the RI idea in a model
    """
    limitTo12(model)
    aftershocks = 0
    #this vinculates magnitude data from SAPP package with earthquakes from them models      
    model=simpleHibrid(model,fileEtasim,"../Zona/paper_exp/testeModelCatalog.txt")
    for (binOfmagMain,index) in zip(model.magnitudeValues,range(len(model.magnitudeValues))):
        for magMain in binOfmagMain:
            if magMain > 0: 
                for t in range(t2):
                    aftershocks += pdfOmoriUtsu(t2=t)*quakesTriggered(magMain)
    ideaRIinMmodels(model, aftershocks)
    aftershocks = 0
    return model

#TODO: I need to talk about this
#This was implemented to be used with Zechar code, but without this some models reach really HIGH values
def limitTo12(model):
    """
    It limits the number of earhtquake in a bin to a max of 12
    """
    for bins,index in zip(model.bins, range(len(model.bins))):
        if bins > 12:
            model.bins[index]=12

    return model


