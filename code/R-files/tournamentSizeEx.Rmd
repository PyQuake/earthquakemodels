---
title: "Tournament Size Experiments"
author: "Yuri Lavinas"
date: "7/27/2017"
output: pdf_document
---

```{r "setup", include=FALSE}
require("knitr")
knitr::opts_knit$set(root.dir = "~/Documents/estudos/master-unb/earthquakemodels/result_exp_benchmark/UniformGaussian20D")
```

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H')
knitr::opts_chunk$set(cache=TRUE)
library(ggplot2)
library(gridExtra)
par(mfrow=c(2,1))
```
#Summary
In this document we show two plots for the GAModel and the GABBOB - a simple GA applied to the BBOB benchmark funtions -  with tournize size (k) from 2 to 25, with the Uniform crossover operator (with 0.1 of independent probability of exchanging an gene) and Gaussian mutation operator with mu=0, sigma=1, 0.1 of independent probability.

Every plot it was calculated the mean, the standart deviation (std) and the confidence interval (C.I) of 40 runs of a configuration. Aa example of a configuration, giben by: evaluation function, tournament size, is GABBOB F1 with k = 2. For each configuration two plots are given. One, with the mean and the standart deviation and the other, with the mean and the CI. The graph shows the values of the mean minus and plus the std, whereas in the second plot, the graph shows mean and the CI, though the valeus are independent.

1. Number of generations: 500 (used to be 100).
2. Population size: 800 (used to be 500).

#Comments

We did some experiments with 40 dimensions, now we are experimenting with 20 dimensions. 

Standart Deviation: F20 (For k = 1...25) -> 0.3577385  1.4522482  0.3722891  0.3342789  0.3203987  0.3432203 0.3179952  0.3193463 15.7308372  0.2495824  0.4440507  0.6733610  1.7549915  9.6024268 10.8827583  0.2660707  0.3039624  0.2499267 0.3054992  0.2952024  2.2356739  0.4414154  0.2572610  0.3786557

#More information

With more dimensions the harder it is for a GA to find precise solutions. I got the idea from Sawyerr et al (Check next paragraph), although they use a much more complex GA (a hybrid one).

Sawyerr et al concluded that the RCGAu has excelled in solving the f1, f2, f3, f7 and f21, tough for the other functions it achieved avarage results. They also state that real value GA do not efficiently solve highly conditioned problems and studies have currently been carried out to find out why [1].

[1] Sawyerr, B.A., Adewumi, A.O., Ali, M.M.: Benchmarking rcgau on the noiseless bbob testbed. The Scientific World Journal 2015 (2015).




## Plots

The order of the plots is: first we show the GAModel plots and the the BBOB benchmark functions, from F1 to F24.

```{r pressure, echo=FALSE}
# #create function to read data with paste - header problems - GA
# loadDataGA_2_10 = function(type, i,  nrows = 500){
#     filename = paste(type,'_',i,'.txt',sep='')
#     data = read.csv(file = filename, header = T, nrows = 200, sep = '\t', skip=1,  nrows = nrows)
#     return(data)
# }
#
# # create function to read data with paste - header problems - GA
# loadDataGA_11_25 = function(type, i,  nrows = 500){
#     filename = paste(type,'_',i,'.txt',sep='')
#     data = read.csv(file = filename, header = T, nrows = 200, sep = '\t', skip=3,  nrows = nrows)
#     return(data)
# }

#create function to read data with paste - benchmarks
loadDataBenchmarksF4_F24 = function(type, i,  nrows = 500, skip=2){
    filename = paste(type,'_',i,'.txt',sep='')
    data = read.csv(file = filename, header = T, sep = '\t',  nrows = nrows, skip=skip)
    return(data)
}

loadDataBenchmarksF1_F3 = function(type, i,  nrows = 500, skip=0){
    filename = paste(type,'_',i,'.txt',sep='')
    data = read.csv(file = filename, header = T, sep = '\t',  nrows = nrows, skip = skip)
    return(data)
}

# # create function to find the mean of the 40 execs
# createMeanFromExecGA = function (name_function, j){
#     vectorAuxMean = c(1:40)
#     for (i in 1:40) {
#         if (j == 2){
#             data=loadDataGA_11_25(name_function,i-1)
#         }
#         else if (j<=10) {
#             data=loadDataGA_2_10(name_function,i-1)
#         }
#         else{
#             data=loadDataGA_11_25(name_function,i-1)
#         }
#         vectorAuxMean[i] = data$max[500]
#     }
#     aux = t.test(vectorAuxMean)
#     df <-data.frame(mean(vectorAuxMean), sd(vectorAuxMean), aux$conf.int[1], aux$conf.int[2])
#     names(df) <- c('mean', 'std', 'five', 'ninetyFive')
#     return(df)
# }
#
#
# # create function to find the max value from a function - the mean of the last gen that counts
# # here im getting the values from the tournsize
# findMaxGA = function(){
#     df<-data.frame()
#     #TODO change from 24 to 25
#     for (i in 2:24){
#         name_function=paste('ga_',i,sep='')
#         aux<-createMeanFromExecGA(name_function, i)
#         df<-rbind(df, aux)
#     }
#     return(df)
# }
#
# # create function to find the max value and where it is located
# findMaxPosGA = function (){
#     vectorAuxMax=findMaxGA()
#     p1<- ggplot(vectorAuxMax, aes(1:nrow(vectorAuxMax), mean, colour=1:nrow(vectorAuxMax))) +
#         geom_errorbar(aes(ymin=vectorAuxMax$mean-vectorAuxMax$std, ymax=vectorAuxMax$mean+vectorAuxMax$std), width=.1) +
#         geom_line() +
#         geom_point() +
#         xlab('tournament size') +
#         ylab('function mean value') +
#         ggtitle(paste("GAModel",' means and std' , sep=''))
#     print(p1+ theme(legend.position="none"))
#
#     p1<- ggplot(vectorAuxMax, aes(1:nrow(vectorAuxMax), mean, colour=vectorAuxMax$mean)) +
#         # geom_errorbar(aes(ymin=vectorAuxMax$mean-vectorAuxMax$std, ymax=vectorAuxMax$mean+vectorAuxMax$std), width=.1) +
#         geom_line() +
#         geom_point() +
#         xlab('tournament size') +
#         ylab('function mean value') +
#         ggtitle(paste("GA",' means and C.I.' , sep='')) +
#         geom_segment(aes(x = 1:nrow(vectorAuxMax), y = vectorAuxMax$five, xend = 1:nrow(vectorAuxMax), yend=vectorAuxMax$ninetyFive))
#     print(p1+ theme(legend.position="none"))
# }
# findMaxPosGA()


# create function to find the mean of the 40 execs
createMeanFromExecBenchmarks = function (name_function, j){
    vectorAuxMean = c(1:40)
    for (i in 1:40) {
        if(j<4){
            data=loadDataBenchmarksF1_F3(name_function,i-1)
        }
        else if(j<19){
            data=loadDataBenchmarksF4_F24(name_function,i-1)
        }
        else{
            data=loadDataBenchmarksF1_F3(name_function,i-1, skip = 0, nrows = 500)
        }

        vectorAuxMean[i] = data$min[500]
    }
    aux = t.test(vectorAuxMean)
    df <-data.frame(mean(vectorAuxMean), sd(vectorAuxMean), aux$conf.int[1], aux$conf.int[2])
    names(df) <- c('mean', 'std', 'five', 'ninetyFive')
    return(df)
}
# mean=createMeanFromExecBenchmarks('F1_2', 0)

# create function to find the max value from a function - the mean of the last gen that counts
# here im getting the values from the tournsize
findMaxBenchmarks = function(benchmarck_index_function){
    df<-data.frame()
    for (i in 2:25){
        name_function=paste('F',benchmarck_index_function,'_',i,sep='')
        aux<-createMeanFromExecBenchmarks(name_function, benchmarck_index_function)
        df<-rbind(df, aux)
    }
    return(df)
}


# create function to find the max value and where it is located
findMaxPosBenchmarks = function (benchmarck_index_function){
    vectorAuxMax=findMaxBenchmarks(benchmarck_index_function)
    p1<- ggplot(vectorAuxMax, aes(1:nrow(vectorAuxMax), mean, colour=vectorAuxMax$mean)) +
        geom_errorbar(aes(ymin=vectorAuxMax$mean-vectorAuxMax$std, ymax=vectorAuxMax$mean+vectorAuxMax$std), width=.1) +
        geom_line() +
        geom_point() +
        xlab('tournament size') +
        ylab('function mean value') +
        ggtitle(paste("F",benchmarck_index_function,' means and std' , sep=''))
    print(p1+ theme(legend.position="none"))

    p1<- ggplot(vectorAuxMax, aes(1:nrow(vectorAuxMax), mean, colour=vectorAuxMax$mean)) +
        # geom_errorbar(aes(ymin=vectorAuxMax$mean-vectorAuxMax$std, ymax=vectorAuxMax$mean+vectorAuxMax$std), width=.1) +
        geom_line() +
        geom_point() +
        xlab('tournament size') +
        ylab('function mean value') +
        ggtitle(paste("F",benchmarck_index_function,' means and C.I.' , sep='')) +
        geom_segment(aes(x = 1:nrow(vectorAuxMax), y = vectorAuxMax$five, xend = 1:nrow(vectorAuxMax), yend=vectorAuxMax$ninetyFive))
    print(p1+ theme(legend.position="none"))
}

for (i in 1:24){
    findMaxPosBenchmarks(i)
}

```


## Convergency Plots

Based on the best values for K, from plots of the last section, we made the convergency plots. Not all k values are represented because the plot are basically the same. Also the std was omitted, because in some plots the difference betwen the std and the mean is very big. In those cases, it was difficult to see any convergency (the line was almost a straight line).

```{r, echo=FALSE}
# setwd("~/Documents/estudos/master-unb/earthquakemodels/result_exp_benchmark/gaBenchmarksStudy")
#create function to read data with paste - header problems - GA
# loadDataGA_2_10 = function(type, i, nrows = 500){
#     filename = paste(type,'_',i,'.txt',sep='')
#     data = read.csv(file = filename, header = T, sep = '\t', skip=1,  nrows = nrows)
#     return(data)
# }
# 
# # create function to read data with paste - header problems - GA
# loadDataGA_11_25 = function(type, i,  nrows = 500){
#     filename = paste(type,'_',i,'.txt',sep='')
#     data = read.csv(file = filename, header = T, sep = '\t', skip=3, nrows = nrows)
#     return(data)
# }
# 
#create function to read data with paste - benchmarks
loadDataBenchmarksF4_F24 = function(type, i,  nrows = 500, skip=2){
    filename = paste(type,'_',i,'.txt',sep='')
    data = read.csv(file = filename, header = T, sep = '\t',  nrows = nrows, skip=skip)
    return(data)
}

loadDataBenchmarksF1_F3 = function(type, i,  nrows = 500, skip=0){
    filename = paste(type,'_',i,'.txt',sep='')
    data = read.csv(file = filename, header = T, sep = '\t',  nrows = nrows, skip = skip)
    return(data)
}
# 
# createConvergencyDataGA = function (name_function, j){
#     df = data.frame()
#     for (i in 1:40) {
#         if (j == 2){
#             data=loadDataGA_11_25(name_function,i-1)    
#         }
#         else if (j<=10) {
#             data=loadDataGA_2_10(name_function,i-1)    
#         }
#         else{
#             data=loadDataGA_11_25(name_function,i-1)    
#         }
#         df <- rbind(df, data)
#     }
#     minimum = (-1)*tapply(df$max, INDEX = df$gen, FUN = mean)
#     # std = tapply(df$std, INDEX = df$gen, FUN = mean)
#     # std = pmin(std, 200)
#     gen = c(1:500)
#     df = data.frame(minimum, std, gen)
#     df
# }
# 
# plotforKGA = function(){
#     # for (j in 2:24){
#     j=5
#     name_function = paste('GA_',j, sep='')
#     # print(name_function)
#     vectorAuxMax = createConvergencyDataGA(name_function, j)
#     p1<- ggplot(vectorAuxMax, aes(gen, minimum, colour=vectorAuxMax$minimum)) + 
#         # geom_errorbar(aes(ymin=vectorAuxMax$minimum-vectorAuxMax$std, ymax=vectorAuxMax$minimum+vectorAuxMax$std), width=.1) +
#         geom_line() +
#         geom_point() +
#         xlab('Number of generations') + 
#         ylab('function mean value') +
#         ggtitle(name_function) #+
#     # geom_segment(aes(x = 1:nrow(vectorAuxMax), y = vectorAuxMax$five, xend = 1:nrow(vectorAuxMax), yend=vectorAuxMax$ninetyFive))
#     print(p1+ theme(legend.position="none"))    
#     # }
#     
# }
# 
# plotforKGA()

createConvergencyDataBenchmarks = function (name_function, j){
    df = data.frame()
    for (i in 1:40) {
        if(j<4){
            data=loadDataBenchmarksF1_F3(name_function,i-1)
        }
        else if(j<19){
            data=loadDataBenchmarksF4_F24(name_function,i-1)
        }
        else{
            data=loadDataBenchmarksF1_F3(name_function,i-1, skip = 0, nrows = 500)
        }
        
        df <- rbind(df, data)
    }
    minimum = tapply(df$min, INDEX = df$gen, FUN = mean)
    std = tapply(df$std, INDEX = df$gen, FUN = mean)
    # std = pmin(std, 200)
    gen = c(1:500)
    df = data.frame(minimum, std, gen)
    df
}

id = c(18, 15,13, 22, 15, 9, 7, 8, 20, 16, 11, 3, 12, 12, 16, 3, 7, 23, 7, 17, 23, 18, 6, 22)
ablines = c(1:24)
for (i in 1:24){
    
    name_function = paste('F',i,'_',2, sep='')
    if(i<4){
        data=loadDataBenchmarksF1_F3(name_function,i-1, 501)
    }
    else if(i<19){
        data=loadDataBenchmarksF4_F24(name_function,i-1, 501)
    }
    else{
        data=loadDataBenchmarksF1_F3(name_function,i-1, skip=0, nrows = 502)
    }
    ablines[i] = data$gen[501]
}


plotforKBenchmarks = function(k){
    # for (j in 2:25){
    j=id[k]
    name_function = paste('F',k,'_',j, sep='')
    vectorAuxMax = createConvergencyDataBenchmarks(name_function, k)
    name_function = paste('F',k, sep='')
    p1<- ggplot(vectorAuxMax, aes(gen, minimum, colour=vectorAuxMax$minimum)) + 
        # geom_errorbar(aes(ymin=vectorAuxMax$minimum-vectorAuxMax$std, ymax=vectorAuxMax$minimum+vectorAuxMax$std), width=.1) +
        geom_line() +
        geom_point() +
        xlab('Number of generations') + 
        ylab('function mean value') +
        geom_hline(yintercept = ablines[k], color = "red") +
        ggtitle(paste(name_function,'with last gen mean: ', vectorAuxMax$minimum[500], 'and target value:', ablines[k]))#+
    # geom_segment(aes(x = 1:nrow(vectorAuxMax), y = vectorAuxMax$five, xend = 1:nrow(vectorAuxMax), yend=vectorAuxMax$ninetyFive))
    print(p1+ theme(legend.position="none"))    
    # }
    
}


for (i in 1:24){
    plotforKBenchmarks(i)
}


```

